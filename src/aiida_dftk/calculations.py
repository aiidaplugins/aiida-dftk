# -*- coding: utf-8 -*-
"""`CalcJob` implementation for DFTK."""
import io
import os
import typing as ty
import json

from aiida import orm
from aiida.engine import CalcJob
from aiida.common import datastructures
from aiida_pseudo.data.pseudo import UpfData


class DftkCalculation(CalcJob):
    """`CalcJob` implementation for DFTK"""

    _DEFAULT_PREFIX = 'DFTK'
    _DEFAULT_INPUT_EXTENSION = '.json'
    _DEFAULT_OUTPUT_EXTENSION = '.hdf5'
    _PSEUDO_SUBFOLDER = './pseudo/'

    @staticmethod
    def _merge_dicts(dict1, dict2):
        """Recursively merge dict2 into dict1."""
        for key, value in dict2.items():
            if key in dict1 and isinstance(dict1[key], dict) and isinstance(value, dict):
                DftkCalculation._merge_dicts(dict1[key], value)
            else:
                dict1[key] = value

    @classmethod
    def define(cls, spec):
        """Define the process specification."""
        super().define(spec)
        #inputs
        spec.input('metadata.options.prefix',
                   valid_type=str,
                   default=cls._DEFAULT_PREFIX)
        spec.input('metadata.options.input_extension',
                   valid_type=str,
                   default=cls._DEFAULT_INPUT_EXTENSION)
        spec.input('metadata.options.output_extension',
                   valid_type=str,
                   default=cls._DEFAULT_OUTPUT_EXTENSION)
        spec.input('metadata.options.withmpi',
                   valid_type=bool,
                   default=True)

        spec.input('structure', valid_type=orm.StructureData,
            help='structure')
        spec.input_namespace('pseudos',
                             valid_type=UpfData,
                             help='The pseudopotentials.',
                             dynamic=True)
        spec.input('kpoints', valid_type=orm.KpointsData,
            help='kpoint mesh or kpoint path')
        spec.input('parameters', valid_type=orm.Dict,
            help='input parameters')
        spec.input('settings',
                   valid_type=orm.Dict,
                   required=False,
                   help='Various special settings.')
        spec.inputs.validator = cls.validate_inputs

        options = spec.inputs['metadata']['options']
        options['resources'].default = {'num_machines': 1, 'num_mpiprocs_per_machine': 1}
        options['input_filename'].default = f'{cls._DEFAULT_PREFIX}.{cls._DEFAULT_INPUT_EXTENSION}'

        #outputs
        spec.output('output_parameters', valid_type=orm.Dict,
            help='output parameters')
        spec.output('output_structure', valid_type=orm.Dict, required=False,
            help='output structure')
        spec.output('output_kpoints', valid_type=orm.KpointsData, required=False,
            help='kpoints array, if generated by DFTK')
        '''
        spec.output('pseudos', valid_type=orm.Dict, required=False,
            help='output pseudopotentials')
        spec.output('trajectory', valid_type=orm.TrajectoryData, required=False,
            help='trajectory data from structure optimization')
        spec.output('bands', valid_type=orm.BandsData, required=False,
            help='eigenvalues array')
        '''
        spec.default_output_node = 'output_parameters'

    @classmethod
    def validate_inputs(cls, value, _):
        """validate input parameters"""
        pass

    def _generate_inputdata(self, parameters: orm.Dict, structure: orm.StructureData, pseudos: orm.UpfData, kpoints: orm.KpointsData) -> ty.Tuple[dict, list]:
        local_copy_pseudo_list=[]

        dict = {"periodic_system":{},"model_kwargs":{},"basis_kwargs":{},"scf":{},"postscf":[]}
        ang_to_bohr = 1.889726125
        dict["periodic_system"]["bounding_box"] = [[x * ang_to_bohr for x in vec] for vec in structure.cell]
        dict["periodic_system"]["atoms"] = []
        for site in structure.sites:
            dict["periodic_system"]["atoms"].append({"symbol":site.kind_name,
                                                     "position": [X * ang_to_bohr for X in list(site.position)],
                                                     "pseudopotential":f'{self._PSEUDO_SUBFOLDER}{pseudos[site.kind_name].filename}'})
            pseudo = pseudos[site.kind_name]
            local_copy_pseudo_list.append((pseudo.uuid, pseudo.filename, f'{self._PSEUDO_SUBFOLDER}{pseudo.filename}'))
        dict["basis_kwargs"]["kgrid"], dict["basis_kwargs"]["kshift"] = kpoints.get_kpoints_mesh()
        DftkCalculation._merge_dicts(dict, parameters.get_dict())

        return dict, local_copy_pseudo_list
    
    
    def _generate_cmdline_params(self) -> ty.List[str]:
        # Define the command based on the input settings
        cmd_params = []
        cmd_params.extend(['--project=/home/max/Desktop/Aiida_DFTK_Test/aiida-dftk/AiidaDFTK.jl', '-e', 'using AiidaDFTK; AiidaDFTK.run()', 'DFTKin.json'])
        return cmd_params

    def _generate_retrieve_list(self, parameters: orm.Dict) -> list:
        pass

    def prepare_for_submission(self, folder):
        """Create the input file(s) from the input nodes.

        :param folder: an `aiida.common.folders.Folder` where the plugin should temporarily place all files needed by
            the calculation.
        :return: `aiida.common.datastructures.CalcInfo` instance
        """
        # Generate the input file content
        arguments = [
            self.inputs.parameters,
            self.inputs.structure,
            self.inputs.pseudos,
            self.inputs.kpoints
        ]
        input_filecontent, local_copy_list = self._generate_inputdata(*arguments)

        # write DFTKin.json input file
        input_filename = folder.get_abs_path('DFTKin.json')
        with io.open(input_filename, 'w', encoding='utf-8') as stream:
            json.dump(input_filecontent, stream)

        # prepare command line parameters
        cmdline_params = self._generate_cmdline_params()

        # prepare retrieve list
        retrieve_list = self._generate_retrieve_list(self.inputs.parameters)

        # Set up the `CodeInfo` to pass to `CalcInfo`
        codeinfo = datastructures.CodeInfo()
        codeinfo.code_uuid = self.inputs.code.uuid
        codeinfo.cmdline_params = cmdline_params
        #codeinfo.withmpi = self.inputs.metadata.options.withmpi

        # Set up the `CalcInfo` so AiiDA knows what to do with everything
        calcinfo = datastructures.CalcInfo()
        calcinfo.codes_info = [codeinfo]
        calcinfo.stdin_name = self.metadata.options.input_filename
        calcinfo.stdout_name = 'scfres.jld2'
        calcinfo.retrieve_list = retrieve_list
        calcinfo.local_copy_list = local_copy_list

        return calcinfo

